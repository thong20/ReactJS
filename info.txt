Ecommerce Web App 01

===== BUILD PROJECT ==========================================================
npm run build => Enter

## ecommerce là thư viện hổ trợ tạo giỏ hàng
cho các ứng dụng

## stripe là 1 dịch vụ hổ trợ thanh toán cho
các ứng dụng

===== react-router-dom ===========================================
- Cấu trúc 1:
import {BrowserRouter as Router, Route, Switch} from 'react-router-dom'
import PageName2 from './PageName2.js'

<Router>
  <Switch>
    <Route exact path='/page-name-1'> 
      // Component target here
    </Route>
    <Route exact path='/page-name-2'> 
      <PageName2 />
    </Route>
  </Switch>
</Router>
*** Giải thích: khi địa chỉ url khớp với giá trị của thuộc tính
path, nó sẽ thực hiện đoạn code bên trong <Route> đó


- Cấu trúc 2: tương tự thẻ <a href='...'> của html
import {Link} from 'react-router-dom'
<div>
  <Link to='/page-name'>Go to Detail</Link>
</div>

- Cấu trúc 3: với cấu trúc này thì ta vẫn giữ lại được
các style của các element. So với cấu trúc 2, thì có
lẻ ta phải style lại, vì đường link sẽ có text-decoration

import {Link} from 'react-router-dom'
import {Typography, IconButton} from '@material-ui/core'

<div>
  <Typography component={Link} to='/page-name'>
    Lorem ipsum ...
  </Typography>
  <IconButton component={Link} to='/page-name' />
</div>


===== commercejs ==============================================
- Khai báo: tạo 1 file commerce.js, nội dung:
import Commerce from '@chec/commerce.js'
export const commerce = new Commerce(process.env.REACT_APP_CHEC_PUBLIC_KEY, true);

- Sử dụng:
import {commerce} from 'commerce.js'
 
- fetchProduct: 
const fetchProduct = async () => {
  const {data} = await commerce.products.list(); // trả về 1 Object, nếu không sử dụng await thì sẽ trả về 1 Promise
  setProducts(data)
}
- fetchCart:
const fetchCart = async () => {
  const cart = await commerce.cart.retrieve(); // trả về 1 Object, nếu không sử dụng await thì sẽ trả về 1 Promise
  setCart(cart)
}

- commerce.products:
commerce.products.list()
commerce.products.

- commerce.cart:
commerce.cart.retrieve()
commerce.cart.add()
commerce.cart.update()
commerce.cart.refresh()

- commerce.checkout
commerce.checkout.generateToken()
commerce.checkout.getShippingOptions()
commerce.checkout.capture()

- commerce.services
commerce.services.localeListShippingCountries()
commerce.services.localeListSubdivisions()

===== STRIPE =============================================================
import {Elements, CardElement, ElementsConsumer} from '@stripe/react-stripe-js'
import {loadStrip} from '@stripe/react-stripe-js'



========================================================================
## CSS:
  - Thuộc tính:
* flexGrow: 1

* [theme.breakpoints.up('sm')]: { // tương tự CSS responsive: @media (min-width:600px): 
      width: `calc(100% - ${drawerWidth}px)`,
      marginLeft: drawerWidth,
  }
với:
xs: 0
sm: 600
md: 960
lg: 1280
xl: 1920

* gutterButtom của Typography ở file Cart.js
thuộc tính này giống như padding/margin Bottom

===========================================================================
## Chuyển string thành thẻ HTML
Sử dụng thuộc tính dangerouslySetInnerHTML
link: https://medium.com/@uigalaxy7/how-to-render-html-in-react-7f3c73f5cafc
vd:
<Typography variant='body2' color='textSecondary'>
  {product.description}
</Typography>
=> Khi sử dụng thuộc tính dangerouslySetInnerHTML, ta code:
<Typography dangerouslySetInnerHTML={{ __html: product.description }} variant='body2' color='textSecondary' />

============================================================================
## <> </>
đây là thẻ React Fragment
component này được sinh ra để giải quyết sự phân mảnh
tìm hiểu thêm tại link: https://reactjs.org/docs/fragments.html
vd: Ta có
// file App.js
<table>
  <tr>
    <Test />
  </tr>
</table>

// file Test.js
...
return (
  <div>
    <td>AAAA</td>
    <td>BBBB</td>
  </div>
)

=> Kết quả ta có DOM:
<table>
  <tr>
    <div>
      <td>AAAA</td>
      <td>BBBB</td>
    </div>
  </tr>
</table>
=> vấn đề xảy ra là xuất hiện thẻ <div> trong thẻ <table>
điều này là không nên, vì vậy <React.Fragment> được sinh ra
để giải quyết vấn đề này
=> ở file Test.js ta sửa lại thẻ <div> thành <React.Fragment>
...
return (
  <React.Fragment>    | <=> | <>
    <td>AAAA</td>     | <=> |   <td>AAAA</td>
    <td>BBBB</td>     | <=> |   <td>BBBB</td>
  </React.Fragment>   | <=> | </>
)

=> để truyền attribute:
 - Nên: <React.Fragment key={...}> ... </React.Fragment>
 - Không nên: < key={...}> ... </> vì sẽ báo lỗi

============================================================================
## react-router-dom
 - Sử dụng <Route exact path='/'>
có thể hiểu 'exact' thường đi chung với 'path'
nghĩa là: dẫn chính xác đến đường dẫn ...

 - Sử dụng <Link>
* Cở bản nhất:
<Link to='/cart'>
  <IconButton aria-label='Show cart items' color='inherit'>
    <Badge badgeContent={totalItems} color='secondary'>
      <ShoppingCart />
    </Badge>
  </IconButton>
</Link>
=> khi sử dụng cách này, nó có 1 nhược điểm là:
thẻ <Link></Link> sẽ có định dạng như thẻ <a></a> của HTML
=> vì thế ta phải style lại các elemet (ở vd này
là <IconButton><Badge><ShoppingCart>) bên trong nó,
trong khi các element đó ta đã được style trước khi đưa vào
<Link></Link>, chẳng hạn: textDecoration: true, color: 'blue', ...v.v...
=> Để khắc phục nhược điểm này ta sử dụng cách 2:

* Cách 2: đưa component <Link> vào giá trị của thuộc tính của element
<IconButton component={Link} to='/cart' aria-label='Show cart items' color='inherit'>
  <Badge badgeContent={totalItems} color='secondary'>
    <ShoppingCart />
  </Badge>
</IconButton>
=> với cách 2 này ta vẫn giữ lại style của <IconButton>, <Badge> và <ShoppingCart>

===== Kiến thức cũ =================================================
Object.key(countries)
Object.entries(shippingCountries)




























































